import { readFileSync } from 'node:fs';
import { writeFileSync } from 'node:fs';
import { dirname, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Read the contract and parse as JSON
const contractPath = resolve(__dirname, 'yappr-social-contract.json');
const contract = JSON.parse(readFileSync(contractPath, 'utf8'));

// Generate Typescript types for each document type, props and indices
const toTsType = (prop) => {
  if (!prop || typeof prop !== 'object') return 'any';
  if (Array.isArray(prop.enum) && prop.type === 'string') {
    return prop.enum.map((v) => JSON.stringify(v)).join(' | ');
  }
  switch (prop.type) {
    case 'string':
      return 'string';
    case 'integer':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'array':
      // Contract uses byte arrays for identifiers; represent as string in app layer
      if (prop.byteArray) return 'string';
      return 'any[]';
    case 'object':
      return 'Record<string, any>';
    default:
      return 'any';
  }
};

const docNames = Object.keys(contract);

let out = '';
out += '// AUTO-GENERATED FILE. Do not edit manually.\n';
out += '// Generated by contracts/contract-to-ts.mjs\n\n';
out += "import { BaseDoc, DataContract, DocumentType, DocIndexSymbol, IndicesOf } from './contract-api'\n\n";

const pascalCase = (s) => s.replace(/(^|[_-])(\w)/g, (_, __, c) => c.toUpperCase());

// Document type name union
out += `export type DocTypeName = ${docNames.map((n) => JSON.stringify(n)).join(' | ')};\n\n`;

// Per-document interfaces and indices
for (const [docName, schema] of Object.entries(contract)) {
  const ifaceName = pascalCase(docName) + 'Document';
  const props = schema.properties || {};
  const required = new Set(schema.required || []);

  // Document interface
  out += `export interface ${ifaceName} extends BaseDoc {\n`;
  for (const [key, spec] of Object.entries(props)) {
    const optional = required.has(key) ? '' : '?';
    out += `  ${key}${optional}: ${toTsType(spec)};\n`;
  }
  // Reflect $createdAt/$updatedAt requiredness if specified in schema
  if (required.has('$createdAt')) {
    out = out.replace('$createdAt?: number;', '$createdAt: number;');
  }
  if (required.has('$updatedAt')) {
    out = out.replace('$updatedAt?: number;', '$updatedAt: number;');
  }
  out += '}\n\n';

  // Index map type and link via symbol
  const indices = Array.isArray(schema.indices) ? schema.indices : [];
  if (indices.length) {
    out += `export type ${pascalCase(docName)}Index = {\n`;
    for (const idx of indices) {
      const fields = Array.isArray(idx.properties)
        ? idx.properties.map((p) => Object.keys(p)[0])
        : [];
      out += `  ${JSON.stringify(idx.name)}: [${fields.map((f) => JSON.stringify(f)).join(', ')}];\n`;
    }
    out += '};\n';
    // Augment document interface with a symbol-typed optional property for inference
    out += `export interface ${ifaceName} { readonly [DocIndexSymbol]?: ${pascalCase(docName)}Index }\n\n`;
    // Export a strongly-typed DocumentType helper for this document
    out += `export class ${pascalCase(docName)} extends DocumentType<${ifaceName}, ${pascalCase(docName)}Index> { constructor(contract: DataContract){ super(contract, ${JSON.stringify(docName)}) } }\n\n`;
  }
}

// Aggregate map type
out += 'export interface DocumentsByType {\n';
for (const docName of docNames) {
  out += `  ${docName}: ${pascalCase(docName)}Document;\n`;
}
out += '}\n';

const outPath = resolve(__dirname, '../lib/contract-types.generated.ts');
writeFileSync(outPath, out);
console.log('Wrote', outPath);
